import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/foundation.dart';

import '../models/smart_plug_data.dart';
import '../models/smart_plug_event.dart';

/// Model class for SmartPlug events.
///
/// Represents an event or alert generated by a smart plug device,
/// such as power threshold exceeded, connection lost, or relay state changed.
class SmartPlugEvent {
  /// Unique identifier for the event
  final String id;
  
  /// Type of event (e.g., "power_alert", "connection_lost")
  final String type;
  
  /// Human-readable message describing the event
  final String message;
  
  /// Severity level of the event (e.g., "info", "warning", "critical")
  final String severity;
  
  /// When the event occurred
  final DateTime timestamp;
  
  /// Additional data associated with the event
  final Map<String, dynamic> data;
  
  /// Whether the event has been acknowledged by the user
  final bool acknowledged;
  
  /// When the event was acknowledged (null if not acknowledged)
  final int? acknowledgedAt;
  
  /// Type of timestamp (realTime or deviceTime)
  final String timestampType;

  SmartPlugEvent({
    required this.id,
    required this.type,
    required this.message,
    required this.severity,
    required this.timestamp,
    this.data = const {},
    this.acknowledged = false,
    this.acknowledgedAt,
    this.timestampType = 'realTime',
  });

  /// Create a SmartPlugEvent from a Firestore document.
  ///
  /// [doc] The Firestore document containing event data
  factory SmartPlugEvent.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>? ?? {};
    final String deviceId = data['deviceId']?.toString() ?? '';
    final String timestampType = data['timestampType']?.toString() ?? 'realTime';
    
    DateTime timestamp;
    if (data['timestamp'] != null) {
      if (timestampType == 'deviceTime' && data['timestamp'] is int) {
        // Record first connection time if needed
        SmartPlugData.recordDeviceFirstConnection(deviceId);
        
        // Convert device time to real time
        timestamp = SmartPlugData.deviceTimeToRealTime(deviceId, data['timestamp'] as int);
      } else if (data['timestamp'] is Timestamp) {
        // Standard Firestore timestamp
        timestamp = (data['timestamp'] as Timestamp).toDate();
      } else if (data['timestamp'] is int) {
        timestamp = DateTime.fromMillisecondsSinceEpoch(data['timestamp'] as int);
      } else {
        timestamp = DateTime.now();
      }
    } else {
      timestamp = DateTime.now();
    }
    
    return SmartPlugEvent(
      id: doc.id,
      type: data['type'] ?? 'unknown',
      message: data['message'] ?? 'No message',
      severity: data['severity'] ?? 'info',
      timestamp: timestamp,
      data: Map<String, dynamic>.from(data['data'] ?? {}),
      acknowledged: data['acknowledged'] ?? false,
      acknowledgedAt: data['acknowledgedAt'] as int?,
      timestampType: timestampType,
    );
  }

  /// Create a SmartPlugEvent from Realtime Database data.
  ///
  /// [data] The database data containing event information
  /// [id] The unique identifier for the event
  factory SmartPlugEvent.fromRTDB(Map<String, dynamic> data, String id) {
    final String deviceId = data['deviceId']?.toString() ?? '';
    final String timestampType = data['timestampType']?.toString() ?? 'realTime';
    
    DateTime timestamp;
    if (data['timestamp'] != null) {
      if (timestampType == 'deviceTime' && data['timestamp'] is int) {
        // Record first connection time if needed
        SmartPlugData.recordDeviceFirstConnection(deviceId);
        
        // Convert device time to real time
        timestamp = SmartPlugData.deviceTimeToRealTime(deviceId, data['timestamp'] as int);
      } else if (data['timestamp'] is int) {
        timestamp = DateTime.fromMillisecondsSinceEpoch(data['timestamp'] as int);
      } else {
        timestamp = DateTime.now();
      }
    } else {
      timestamp = DateTime.now();
    }
    
    return SmartPlugEvent(
      id: id,
      type: data['type'] ?? 'unknown',
      message: data['message'] ?? 'No message',
      severity: data['severity'] ?? 'info',
      timestamp: timestamp,
      data: Map<String, dynamic>.from(data['data'] ?? {}),
      acknowledged: false,
      acknowledgedAt: null,
      timestampType: timestampType,
    );
  }

  /// Convert the event to a Map for storage.
  ///
  /// Returns a Map representation of the event
  Map<String, dynamic> toMap() {
    final map = {
      'id': id,
      'type': type,
      'message': message,
      'severity': severity,
      'timestamp': timestamp.millisecondsSinceEpoch,
      'data': data,
      'acknowledged': acknowledged,
      'timestampType': timestampType,
    };
    
    if (acknowledgedAt != null) {
      map['acknowledgedAt'] = acknowledgedAt;
    }
    
    return map;
  }
  
  /// Create a copy of this event with updated fields.
  ///
  /// Returns a new SmartPlugEvent with the specified fields updated
  SmartPlugEvent copyWith({
    String? id,
    String? type,
    String? message,
    String? severity,
    DateTime? timestamp,
    Map<String, dynamic>? data,
    bool? acknowledged,
    int? acknowledgedAt,
    String? timestampType,
  }) {
    return SmartPlugEvent(
      id: id ?? this.id,
      type: type ?? this.type,
      message: message ?? this.message,
      severity: severity ?? this.severity,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
      acknowledged: acknowledged ?? this.acknowledged,
      acknowledgedAt: acknowledgedAt ?? this.acknowledgedAt,
      timestampType: timestampType ?? this.timestampType,
    );
  }
}

/// Service responsible for managing smart plug events and alert history.
///
/// This service handles:
/// - Processing and storing events from smart plug devices
/// - Categorizing events by type (alert, notification, status change)
/// - Managing event history and retrieval
/// - Providing queryable access to historical events
/// - Supporting acknowledgment of critical alerts
/// - Archiving and cleanup of old events
///
/// The service provides a comprehensive event management system that
/// supports both real-time event processing and historical event analysis.
class EventService {
  // Firebase instances
  final FirebaseDatabase _database = FirebaseDatabase.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  
  // State tracking
  bool _isInitialized = false;
  String? _activeDeviceId;
  
  // Stream controllers
  final StreamController<SmartPlugEvent> _eventStreamController = 
      StreamController<SmartPlugEvent>.broadcast();
  
  // Event listeners and subscriptions
  StreamSubscription<QuerySnapshot>? _deviceEventsSubscription;
  
  /// Stream of smart plug events that UI components can listen to.
  ///
  /// Emits SmartPlugEvent objects whenever new events are detected,
  /// allowing UI components to react in real-time.
  Stream<SmartPlugEvent> get eventStream => _eventStreamController.stream;
  
  /// Initialize the service and establish connections.
  ///
  /// This must be called before using any other methods in the service.
  /// Sets up authentication state listeners and prepares for event processing.
  Future<void> initialize() async {
    if (_isInitialized) return;
    
    // Set up authentication state listener
    _auth.authStateChanges().listen((User? user) {
      if (user != null) {
        // User signed in, prepare to handle events
        debugPrint('EventService: User authenticated, ready to process events');
      } else {
        // User signed out, clean up
        _cleanupSubscriptions();
        debugPrint('EventService: User signed out, cleaned up resources');
      }
    });
    
    _isInitialized = true;
    debugPrint('EventService initialized');
  }
  
  /// Set the currently active device ID.
  ///
  /// Updates which device's events should be monitored more closely,
  /// typically the one the user is currently viewing in the UI.
  ///
  /// [deviceId] The ID of the device to set as active
  void setActiveDevice(String deviceId) {
    if (_activeDeviceId == deviceId) return;
    
    _activeDeviceId = deviceId;
    _setupDeviceEventListener();
    
    debugPrint('EventService: Active device set to $deviceId');
  }
  
  /// Set up real-time listener for events from the active device.
  ///
  /// Establishes a Firestore query that monitors for new events
  /// from the currently active device.
  void _setupDeviceEventListener() {
    // Clean up existing subscription first
    _deviceEventsSubscription?.cancel();
    
    if (_activeDeviceId == null || _auth.currentUser == null) return;
    
    try {
      // Create query for device events, ordered by timestamp
      final query = _firestore
          .collection('devices')
          .doc(_activeDeviceId)
          .collection('events')
          .orderBy('timestamp', descending: true)
          .limit(50);  // Limit to most recent events
      
      // Subscribe to query
      _deviceEventsSubscription = query.snapshots().listen((snapshot) {
        for (final change in snapshot.docChanges) {
          // Only process added events
          if (change.type == DocumentChangeType.added) {
            final eventData = change.doc.data();
            if (eventData != null) {
              // Create event object and add to stream
              final event = SmartPlugEvent.fromFirestore(
                deviceId: _activeDeviceId!,
                eventId: change.doc.id,
                data: eventData,
              );
              
              _eventStreamController.add(event);
              debugPrint('EventService: New event processed - ${event.type}');
            }
          }
        }
      }, onError: (error) {
        debugPrint('EventService: Error listening to device events: $error');
      });
      
      debugPrint('EventService: Event listener set up for device $_activeDeviceId');
    } catch (e) {
      debugPrint('EventService: Error setting up event listener: $e');
    }
  }
  
  /// Record a new event for a smart plug device.
  ///
  /// Creates a new event entry in Firestore for historical tracking.
  ///
  /// [event] The SmartPlugEvent to record
  /// Returns a Future that completes when the event is recorded
  Future<void> recordEvent(SmartPlugEvent event) async {
    if (_auth.currentUser == null) {
      return Future.error('User not authenticated');
    }
    
    try {
      // Create event document in Firestore
      await _firestore
          .collection('devices')
          .doc(event.deviceId)
          .collection('events')
          .add(event.toFirestore());
      
      // Also store in user's events collection for quick access
      await _firestore
          .collection('users')
          .doc(_auth.currentUser!.uid)
          .collection('events')
          .add({
            ...event.toFirestore(),
            'device_id': event.deviceId,
          });
      
      debugPrint('EventService: Recorded new event for device ${event.deviceId}');
      return Future.value();
    } catch (e) {
      debugPrint('EventService: Error recording event: $e');
      return Future.error(e);
    }
  }
  
  /// Acknowledge an alert event.
  ///
  /// Updates the event document to mark it as acknowledged by the user,
  /// which can be used to stop repeated notifications or visual indicators.
  ///
  /// [eventId] The ID of the event to acknowledge
  /// [deviceId] The ID of the device the event belongs to
  /// Returns a Future that completes when the event is acknowledged
  Future<void> acknowledgeEvent(String eventId, String deviceId) async {
    if (_auth.currentUser == null) {
      return Future.error('User not authenticated');
    }
    
    try {
      // Update event document in Firestore
      await _firestore
          .collection('devices')
          .doc(deviceId)
          .collection('events')
          .doc(eventId)
          .update({
            'acknowledged': true,
            'acknowledged_at': FieldValue.serverTimestamp(),
            'acknowledged_by': _auth.currentUser!.uid,
          });
      
      // Also update in user's events collection
      final userEventsQuery = await _firestore
          .collection('users')
          .doc(_auth.currentUser!.uid)
          .collection('events')
          .where('event_id', isEqualTo: eventId)
          .limit(1)
          .get();
      
      if (userEventsQuery.docs.isNotEmpty) {
        await userEventsQuery.docs.first.reference.update({
          'acknowledged': true,
          'acknowledged_at': FieldValue.serverTimestamp(),
          'acknowledged_by': _auth.currentUser!.uid,
        });
      }
      
      debugPrint('EventService: Acknowledged event $eventId');
      return Future.value();
    } catch (e) {
      debugPrint('EventService: Error acknowledging event: $e');
      return Future.error(e);
    }
  }
  
  /// Get recent events for a specific device.
  ///
  /// Retrieves the most recent events for a device, ordered by timestamp.
  ///
  /// [deviceId] The ID of the device to get events for
  /// [limit] Maximum number of events to retrieve (default: 20)
  /// Returns a Future that resolves to a list of SmartPlugEvent objects
  Future<List<SmartPlugEvent>> getRecentEvents(String deviceId, {int limit = 20}) async {
    if (_auth.currentUser == null) {
      return Future.error('User not authenticated');
    }
    
    try {
      final eventsSnapshot = await _firestore
          .collection('devices')
          .doc(deviceId)
          .collection('events')
          .orderBy('timestamp', descending: true)
          .limit(limit)
          .get();
      
      final events = eventsSnapshot.docs.map((doc) {
        return SmartPlugEvent.fromFirestore(
          deviceId: deviceId,
          eventId: doc.id,
          data: doc.data(),
        );
      }).toList();
      
      debugPrint('EventService: Retrieved ${events.length} recent events for device $deviceId');
      return events;
    } catch (e) {
      debugPrint('EventService: Error getting recent events: $e');
      return [];
    }
  }
  
  /// Get events of a specific type for a device.
  ///
  /// Retrieves events filtered by their type (alert, notification, status).
  ///
  /// [deviceId] The ID of the device to get events for
  /// [eventType] The type of events to retrieve
  /// [limit] Maximum number of events to retrieve (default: 20)
  /// Returns a Future that resolves to a list of SmartPlugEvent objects
  Future<List<SmartPlugEvent>> getEventsByType(
      String deviceId, String eventType, {int limit = 20}) async {
    if (_auth.currentUser == null) {
      return Future.error('User not authenticated');
    }
    
    try {
      final eventsSnapshot = await _firestore
          .collection('devices')
          .doc(deviceId)
          .collection('events')
          .where('type', isEqualTo: eventType)
          .orderBy('timestamp', descending: true)
          .limit(limit)
          .get();
      
      final events = eventsSnapshot.docs.map((doc) {
        return SmartPlugEvent.fromFirestore(
          deviceId: deviceId,
          eventId: doc.id,
          data: doc.data(),
        );
      }).toList();
      
      debugPrint('EventService: Retrieved ${events.length} $eventType events for device $deviceId');
      return events;
    } catch (e) {
      debugPrint('EventService: Error getting events by type: $e');
      return [];
    }
  }
  
  /// Get historical events within a date range.
  ///
  /// Retrieves events that occurred between the specified start and end dates.
  ///
  /// [deviceId] The ID of the device to get events for
  /// [startDate] The start date of the range (inclusive)
  /// [endDate] The end date of the range (inclusive)
  /// [limit] Maximum number of events to retrieve (default: 100)
  /// Returns a Future that resolves to a list of SmartPlugEvent objects
  Future<List<SmartPlugEvent>> getHistoricalEvents(
      String deviceId, DateTime startDate, DateTime endDate, {int limit = 100}) async {
    if (_auth.currentUser == null) {
      return Future.error('User not authenticated');
    }
    
    try {
      final startTimestamp = Timestamp.fromDate(startDate);
      final endTimestamp = Timestamp.fromDate(endDate);
      
      final eventsSnapshot = await _firestore
          .collection('devices')
          .doc(deviceId)
          .collection('events')
          .where('timestamp', isGreaterThanOrEqualTo: startTimestamp)
          .where('timestamp', isLessThanOrEqualTo: endTimestamp)
          .orderBy('timestamp', descending: true)
          .limit(limit)
          .get();
      
      final events = eventsSnapshot.docs.map((doc) {
        return SmartPlugEvent.fromFirestore(
          deviceId: deviceId,
          eventId: doc.id,
          data: doc.data(),
        );
      }).toList();
      
      debugPrint('EventService: Retrieved ${events.length} historical events for device $deviceId');
      return events;
    } catch (e) {
      debugPrint('EventService: Error getting historical events: $e');
      return [];
    }
  }
  
  /// Get unacknowledged alert events.
  ///
  /// Retrieves critical alert events that have not yet been acknowledged
  /// by the user, useful for displaying active alerts.
  ///
  /// [deviceId] The ID of the device to get alerts for (optional)
  /// Returns a Future that resolves to a list of SmartPlugEvent objects
  Future<List<SmartPlugEvent>> getUnacknowledgedAlerts({String? deviceId}) async {
    if (_auth.currentUser == null) {
      return Future.error('User not authenticated');
    }
    
    try {
      Query query = _firestore
          .collection('users')
          .doc(_auth.currentUser!.uid)
          .collection('events')
          .where('type', isEqualTo: 'alert')
          .where('acknowledged', isEqualTo: false);
      
      // Add device filter if specified
      if (deviceId != null) {
        query = query.where('device_id', isEqualTo: deviceId);
      }
      
      final alertsSnapshot = await query
          .orderBy('timestamp', descending: true)
          .get();
      
      final alerts = alertsSnapshot.docs.map((doc) {
        final data = doc.data();
        return SmartPlugEvent.fromFirestore(
          deviceId: data['device_id'],
          eventId: data['event_id'] ?? doc.id,
          data: data,
        );
      }).toList();
      
      debugPrint('EventService: Retrieved ${alerts.length} unacknowledged alerts');
      return alerts;
    } catch (e) {
      debugPrint('EventService: Error getting unacknowledged alerts: $e');
      return [];
    }
  }
  
  /// Clean up old events for a device.
  ///
  /// Deletes events older than the specified retention period to
  /// manage storage usage and improve query performance.
  ///
  /// [deviceId] The ID of the device to clean up events for
  /// [retentionDays] Number of days to retain events (default: 30)
  /// Returns a Future that completes when cleanup is finished
  Future<void> cleanupOldEvents(String deviceId, {int retentionDays = 30}) async {
    if (_auth.currentUser == null) {
      return Future.error('User not authenticated');
    }
    
    try {
      // Calculate cutoff date
      final cutoffDate = DateTime.now().subtract(Duration(days: retentionDays));
      final cutoffTimestamp = Timestamp.fromDate(cutoffDate);
      
      // Get old events
      final oldEventsSnapshot = await _firestore
          .collection('devices')
          .doc(deviceId)
          .collection('events')
          .where('timestamp', isLessThan: cutoffTimestamp)
          .limit(100)  // Delete in batches to avoid timeout
          .get();
      
      // Delete events in batches
      final batch = _firestore.batch();
      int count = 0;
      
      for (final doc in oldEventsSnapshot.docs) {
        batch.delete(doc.reference);
        count++;
        
        // Commit batch when it reaches max size
        if (count >= 500) {
          await batch.commit();
          count = 0;
        }
      }
      
      // Commit any remaining deletes
      if (count > 0) {
        await batch.commit();
      }
      
      debugPrint('EventService: Cleaned up ${oldEventsSnapshot.docs.length} old events for device $deviceId');
      return Future.value();
    } catch (e) {
      debugPrint('EventService: Error cleaning up old events: $e');
      return Future.error(e);
    }
  }
  
  /// Clean up resources when the user signs out or the service is no longer needed.
  ///
  /// Cancels event subscriptions to prevent memory leaks.
  void _cleanupSubscriptions() {
    _deviceEventsSubscription?.cancel();
    _deviceEventsSubscription = null;
    _activeDeviceId = null;
  }
  
  /// Dispose of resources when the service is no longer needed.
  ///
  /// Cleans up all subscriptions and controllers to prevent memory leaks.
  void dispose() {
    _cleanupSubscriptions();
    _eventStreamController.close();
    _isInitialized = false;
    
    debugPrint('EventService disposed');
  }
} 
} 